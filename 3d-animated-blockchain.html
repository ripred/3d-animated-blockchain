<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>3D Node Network Simulation - Interactive</title>
  <style>
    body { margin: 0; overflow: hidden; background:#222; color: #eee; font-family: sans-serif; }
    #canvas-container { width: 100vw; height: 100vh; }
    /* Ensure dat.gui is visible and usable */
    .dg.main .close-button { background-color: #333; }
    .dg li:not(.folder) { background: #333; border-bottom: 1px solid #444; }
    .dg .cr.boolean:hover { background: #444; }
    
    /* Make numeric input fields wider */
    .dg .cr.number input[type=text] { 
        color: #eee;
        width: 85px !important; /* Increased width */
    }
    .dg .cr.string input[type=text] { color: #eee; }
    .dg .cr.color .c input[type=text] { color: #eee !important; }
    .dg .ac { /* For action buttons */
        background: #444 !important;
        border-bottom: 1px solid #555 !important;
        color: #eee !important;
        font-weight: bold !important;
    }
    .dg .ac:hover {
        background: #555 !important;
    }
    /* Styles for the generated code popup buttons */
    #generatedCodeContainer button {
        margin-top: 10px;
        padding: 8px 15px;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-weight: bold;
    }
    #copyGeneratedCode {
        background: #007bff; /* Blue for copy */
        color: white;
        margin-left: 5px;
    }
    #copyGeneratedCode:hover {
        background: #0056b3;
    }
    #closeGeneratedCode {
        background: #6c757d; /* Gray for close */
        color: white;
    }
    #closeGeneratedCode:hover {
        background: #545b62;
    }
  </style>
</head>
<body>
<div id="canvas-container"></div>
<div id="generatedCodeContainer" style="display:none; position: fixed; top: 10px; right: 10px; width: 45%; height: 80%; background: rgba(0,0,0,0.85); border: 1px solid #555; overflow: auto; z-index: 1000; padding: 15px; box-sizing: border-box; border-radius: 8px; box-shadow: 0 4px 15px rgba(0,0,0,0.5);">
  <h3 style="margin-top:0; color: #fff;">Generated Embeddable App Code:</h3>
  <textarea id="generatedCodeOutput" style="width: 100%; height: calc(100% - 80px); background: #1e1e1e; color: #d4d4d4; border: 1px solid #333; font-family: monospace; font-size: 0.8em; box-sizing: border-box; border-radius: 4px; padding: 10px;"></textarea>
  <div style="text-align: right;">
    <button id="copyGeneratedCode">Copy Code</button>
    <button id="closeGeneratedCode">Close</button>
  </div>
</div>

<script type="module">
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.142.0/build/three.module.js';
import { GUI } from 'https://unpkg.com/dat.gui@0.7.9/build/dat.gui.module.js';

// ========= Globals =========
let scene, camera, renderer;
let graphGroup, pulsesGroup;
let nodeMeshes = [];
let edges = [], pulses = [];
const clock = new THREE.Clock();
let directionalLight, hemisphereLight; // Keep references for potential updates

// Colors for random cubes
const COLORS = [0xff0000, 0x2196f3, 0xffc107, 0x9c27b0, 0x4caf50, 0xf44336, 0xe91e63, 0x673ab7, 0x00bcd4, 0x8bc34a];

// Local Storage Keys
const SECRET_STORAGE_KEY = 'simulationSecretKeyExists_v2'; // Incremented version for new structure
const PARAMS_STORAGE_KEY = 'simulationParams_v2';         // Incremented version

// ========= Parameters (Default values, might be overridden by local storage) =========
const params = {
  globalScale: 1.0,
  nodeCount: 12,
  nodeColor: '#0029ff', 
  lineColor: '#999999', 
  lineThickness: 1.0,    
  radius: 5.0,                 
  nodeSize: 0.5,             
  cubeSize: 0.25,            
  pulseCount: 14,          
  pulseSpeed: 0.23,        
  rotationXIncrement: 0.0,    
  rotationYIncrement: 0.004, 
  rotationZIncrement: 0.0,    
  cubeInteriorColor: '#ff0000', 
  randomCubeColor: false,
  softInternalCubeLight: true, // New: Option for internal cube glow
  nodeTakesPulseColor: false,
  generateApp: function() { generateEmbeddableApp(); } 
};

// ========= Local Storage Functions =========
function saveParamsToLocalStorage() {
  try {
    const paramsToSave = { ...params };
    delete paramsToSave.generateApp; 
    localStorage.setItem(PARAMS_STORAGE_KEY, JSON.stringify(paramsToSave));
    localStorage.setItem(SECRET_STORAGE_KEY, 'true'); 
    // console.log('Parameters saved to local storage.');
  } catch (e) {
    console.error('Failed to save parameters to local storage:', e);
  }
}

function loadParamsFromLocalStorage() {
  try {
    if (localStorage.getItem(SECRET_STORAGE_KEY)) {
      const storedParamsString = localStorage.getItem(PARAMS_STORAGE_KEY);
      if (storedParamsString) {
        const loadedParams = JSON.parse(storedParamsString);
        for (const key in params) { // Iterate over default params to ensure all keys are considered
          if (loadedParams.hasOwnProperty(key) && key !== 'generateApp') {
            params[key] = loadedParams[key];
          }
        }
        console.log('Parameters loaded from local storage.');
      }
    } else {
      console.log('No secret key found. Saving default parameters to local storage.');
      saveParamsToLocalStorage();
    }
  } catch (e) {
    console.error('Failed to load or parse parameters from local storage:', e);
    saveParamsToLocalStorage();
  }
}


// ========= Scaled Value Getters =========
const getScaledRadius = () => params.radius * params.globalScale;
const getScaledNodeSize = () => params.nodeSize * params.globalScale;
const getScaledCubeSize = () => params.cubeSize * params.globalScale;
const getScaledLineThickness = () => params.lineThickness * params.globalScale;

init();

// ========= Init =========
function init() {
  loadParamsFromLocalStorage(); 

  scene = new THREE.Scene();
  camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
  camera.position.set(10 * params.globalScale, 10 * params.globalScale, 15 * params.globalScale); // Adjusted camera for better view with scale
  camera.lookAt(0, 0, 0);

  renderer = new THREE.WebGLRenderer({ antialias: true }); 
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.shadowMap.enabled = true; // Enable shadows
  renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Softer shadows
  document.getElementById('canvas-container').appendChild(renderer.domElement);

  // Enhanced Lighting
  scene.add(new THREE.AmbientLight(0x404040, 0.5)); // Reduced intensity as HemisphereLight is added

  hemisphereLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.8); // Sky, Ground, Intensity
  hemisphereLight.position.set(0, 20, 0);
  scene.add(hemisphereLight);

  directionalLight = new THREE.DirectionalLight(0xffffff, 0.8); // Color, Intensity
  directionalLight.position.set(15, 20, 10); // Position the light
  directionalLight.castShadow = true;
  // Configure shadow properties
  directionalLight.shadow.mapSize.width = 1024; // default 512
  directionalLight.shadow.mapSize.height = 1024; // default 512
  directionalLight.shadow.camera.near = 0.5;    // default 0.5
  directionalLight.shadow.camera.far = 50;     // default 500
  directionalLight.shadow.camera.left = -15 * params.globalScale;
  directionalLight.shadow.camera.right = 15 * params.globalScale;
  directionalLight.shadow.camera.top = 15 * params.globalScale;
  directionalLight.shadow.camera.bottom = -15 * params.globalScale;
  scene.add(directionalLight);
  // const dlHelper = new THREE.DirectionalLightHelper(directionalLight, 5); // Optional: Helper to visualize light
  // scene.add(dlHelper);
  // const shadowCamHelper = new THREE.CameraHelper(directionalLight.shadow.camera); // Optional: Helper
  // scene.add(shadowCamHelper);


  graphGroup  = new THREE.Group();
  pulsesGroup = new THREE.Group();
  scene.add(graphGroup, pulsesGroup);

  setupGUI(); 
  window.addEventListener('resize', onResize);
  rebuild(); 
  animate();
}

// ========= GUI =========
function setupGUI() {
  const gui = new GUI();

  function addControl(folderOrGui, paramKey, ...args) {
    const controller = folderOrGui.add(params, paramKey, ...args);
    // Attach a generic onChange that calls saveParamsToLocalStorage
    // Specific rebuild/rebuildPulses calls are handled in the main onChange for the controller
    controller.onChange(saveParamsToLocalStorage);
    return controller;
  }
  function addColorControl(folderOrGui, paramKey, name) {
    const controller = folderOrGui.addColor(params, paramKey).name(name);
    controller.onChange(saveParamsToLocalStorage);
    return controller;
  }

  const globalFolder = gui.addFolder('Global Settings');
  addControl(globalFolder, 'globalScale', 0.1, 3.0, 0.01).name('Global Scale').onChange(() => { 
      rebuild(); 
      // Update shadow camera for directional light on scale change
      if(directionalLight) {
        directionalLight.shadow.camera.left = -15 * params.globalScale;
        directionalLight.shadow.camera.right = 15 * params.globalScale;
        directionalLight.shadow.camera.top = 15 * params.globalScale;
        directionalLight.shadow.camera.bottom = -15 * params.globalScale;
        directionalLight.shadow.camera.updateProjectionMatrix();
        // if (shadowCamHelper) shadowCamHelper.update();
      }
      saveParamsToLocalStorage(); 
    });
  
  const structureFolder = gui.addFolder('Graph Structure');
  addControl(structureFolder, 'nodeCount', 2, 50, 1).name('Node Count').onChange(() => { rebuild(); saveParamsToLocalStorage(); });
  addControl(structureFolder, 'radius', 1, 10, 0.1).name('Base Radius').onChange(() => { rebuild(); saveParamsToLocalStorage(); });

  const nodeFolder = gui.addFolder('Node Appearance');
  addColorControl(nodeFolder, 'nodeColor', 'Node Color').onChange(() => { rebuild(); saveParamsToLocalStorage(); });
  addControl(nodeFolder, 'nodeSize', 0.1, 1, 0.05).name('Base Node Size').onChange(() => { rebuild(); saveParamsToLocalStorage(); });

  const cubeFolder = gui.addFolder('Cube Appearance');
  addControl(cubeFolder, 'cubeSize', 0.05, 0.5, 0.01).name('Base Cube Size').onChange(() => { rebuild(); saveParamsToLocalStorage(); });
  addColorControl(cubeFolder, 'cubeInteriorColor', 'Cube Interior Color').onChange(() => {
      if (!params.randomCubeColor) rebuildPulses();
      saveParamsToLocalStorage();
  });
  addControl(cubeFolder, 'randomCubeColor').name('Random Cube Color').onChange(() => { rebuildPulses(); saveParamsToLocalStorage(); });
  addControl(cubeFolder, 'softInternalCubeLight').name('Soft Internal Light').onChange(() => { rebuildPulses(); saveParamsToLocalStorage(); }); // New control

  const lineFolder = gui.addFolder('Line Appearance');
  addColorControl(lineFolder, 'lineColor', 'Line Color').onChange(() => { rebuild(); saveParamsToLocalStorage(); });
  addControl(lineFolder, 'lineThickness', 0.1, 10.0, 0.1).name('Base Line Thickness').onChange(() => { rebuild(); saveParamsToLocalStorage(); }); 
  
  const animationFolder = gui.addFolder('Animation & Interaction');
  addControl(animationFolder, 'pulseCount', 0, 100, 1).name('Pulse Count').onChange(() => { rebuildPulses(); saveParamsToLocalStorage(); });
  addControl(animationFolder, 'pulseSpeed', 0.05, 1, 0.01).name('Pulse Speed').onChange(saveParamsToLocalStorage); 
  addControl(animationFolder, 'rotationXIncrement', -0.01, 0.01, 0.0001).name('Rotation X Incr.').onChange(saveParamsToLocalStorage);
  addControl(animationFolder, 'rotationYIncrement', -0.01, 0.01, 0.0001).name('Rotation Y Incr.').onChange(saveParamsToLocalStorage);
  addControl(animationFolder, 'rotationZIncrement', -0.01, 0.01, 0.0001).name('Rotation Z Incr.').onChange(saveParamsToLocalStorage);
  addControl(animationFolder, 'nodeTakesPulseColor').name('Node Takes Pulse Color').onChange(saveParamsToLocalStorage);
  
  gui.add(params, 'generateApp').name('Generate Embeddable App');

  document.getElementById('closeGeneratedCode').addEventListener('click', () => {
    document.getElementById('generatedCodeContainer').style.display = 'none';
  });

  const copyButton = document.getElementById('copyGeneratedCode');
  const codeOutputTextarea = document.getElementById('generatedCodeOutput');

  copyButton.addEventListener('click', async () => {
    codeOutputTextarea.focus(); 
    codeOutputTextarea.select();
    codeOutputTextarea.setSelectionRange(0, codeOutputTextarea.value.length + 1); 

    let copied = false;
    let primaryError = null;

    if (navigator.clipboard && navigator.clipboard.writeText) {
      try {
        await navigator.clipboard.writeText(codeOutputTextarea.value);
        copied = true;
        copyButton.textContent = 'Copied!';
      } catch (err) {
        primaryError = err;
        console.error('Clipboard API failed: ', err);
        copyButton.textContent = 'API Copy Fail'; 
      }
    } else {
        copyButton.textContent = 'No Clipboard API'; 
        primaryError = new Error("navigator.clipboard.writeText not available.");
    }

    if (!copied) { 
      console.log('Attempting fallback copy method...');
      try {
        codeOutputTextarea.focus();
        codeOutputTextarea.select();
        copied = document.execCommand('copy');
        if (copied) {
          copyButton.textContent = 'Copied (Fallback)!';
        } else {
          copyButton.textContent = 'Fallback Fail';
          console.error('Fallback document.execCommand("copy") failed.');
        }
      } catch (err) {
        console.error('Fallback copy method error: ', err);
        copyButton.textContent = 'Fallback Error';
      }
    }
    
    if (!copied && primaryError) {
        console.error('All copy methods failed. Primary error:', primaryError);
    }

    setTimeout(() => {
      copyButton.textContent = 'Copy Code';
    }, 2500); 
  });
}

// ========= Platonic Solid Vertex Calculation =========
function getPlatonicSolidVertices(count, radius) {
    let points = [];
    const p = (1 + Math.sqrt(5)) / 2; 
    const ip = 1 / p; 

    switch (count) {
        case 4: 
            points = [ new THREE.Vector3(1, 1, 1), new THREE.Vector3(1, -1, -1), new THREE.Vector3(-1, 1, -1), new THREE.Vector3(-1, -1, 1) ];
            break;
        case 6: 
            points = [ new THREE.Vector3(1, 0, 0), new THREE.Vector3(-1, 0, 0), new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, -1, 0), new THREE.Vector3(0, 0, 1), new THREE.Vector3(0, 0, -1) ];
            break;
        case 8: 
            points = [ new THREE.Vector3(1,1,1),new THREE.Vector3(1,1,-1),new THREE.Vector3(1,-1,1),new THREE.Vector3(1,-1,-1),new THREE.Vector3(-1,1,1),new THREE.Vector3(-1,1,-1),new THREE.Vector3(-1,-1,1),new THREE.Vector3(-1,-1,-1) ];
            break;
        case 12: 
            const X_ico = 0.525731112119133606; const Z_ico = 0.850650808352039932;
            points = [ new THREE.Vector3(-X_ico,0,Z_ico),new THREE.Vector3(X_ico,0,Z_ico),new THREE.Vector3(-X_ico,0,-Z_ico),new THREE.Vector3(X_ico,0,-Z_ico),new THREE.Vector3(0,Z_ico,X_ico),new THREE.Vector3(0,Z_ico,-X_ico),new THREE.Vector3(0,-Z_ico,X_ico),new THREE.Vector3(0,-Z_ico,-X_ico),new THREE.Vector3(Z_ico,X_ico,0),new THREE.Vector3(-Z_ico,X_ico,0),new THREE.Vector3(Z_ico,-X_ico,0),new THREE.Vector3(-Z_ico,-X_ico,0) ];
            return points.map(pt => pt.multiplyScalar(radius));
        case 20: 
            points = [ new THREE.Vector3(1,1,1),new THREE.Vector3(1,1,-1),new THREE.Vector3(1,-1,1),new THREE.Vector3(1,-1,-1),new THREE.Vector3(-1,1,1),new THREE.Vector3(-1,1,-1),new THREE.Vector3(-1,-1,1),new THREE.Vector3(-1,-1,-1) ];
            const p_coords = [ new THREE.Vector3(0,ip,p),new THREE.Vector3(0,ip,-p),new THREE.Vector3(0,-ip,p),new THREE.Vector3(0,-ip,-p),new THREE.Vector3(ip,p,0),new THREE.Vector3(ip,-p,0),new THREE.Vector3(-ip,p,0),new THREE.Vector3(-ip,-p,0),new THREE.Vector3(p,0,ip),new THREE.Vector3(p,0,-ip),new THREE.Vector3(-p,0,ip),new THREE.Vector3(-p,0,-ip) ];
            p_coords.forEach(v => points.push(v));
            break;
        default: return [];
    }
    return points.map(pt => pt.normalize().multiplyScalar(radius));
}

// ========= Helper =========
function makeCube(defaultColor) { // Removed transparent param, handled by softInternalCubeLight
  const s = getScaledCubeSize();
  const geom = new THREE.BoxGeometry(s, s, s);
  let chosenColorHex;
  if (params.randomCubeColor) { 
    chosenColorHex = COLORS[Math.floor(Math.random() * COLORS.length)];
  } else {
    chosenColorHex = new THREE.Color(defaultColor).getHex();
  }

  const isTransparent = params.softInternalCubeLight;
  const opacity = isTransparent ? 0.85 : 1.0;

  const fillMaterial = new THREE.MeshStandardMaterial({ 
    color: chosenColorHex, 
    emissive: chosenColorHex, // Emissive contributes to glow
    emissiveIntensity: params.softInternalCubeLight ? 0.5 : 0.2, // More emissive if internal light is on
    roughness: 0.6, 
    metalness: 0.1,
    transparent: isTransparent,
    opacity: opacity
  });
  const cubeMesh = new THREE.Mesh(geom, fillMaterial);
  cubeMesh.castShadow = true; // Cubes should cast shadows
  
  const edgeGeom = new THREE.EdgesGeometry(geom); 
  const edgeMat = new THREE.LineBasicMaterial({ 
      color: 0x000000, 
      transparent: isTransparent, // Edges also transparent if cube is
      opacity: isTransparent ? 0.5 : 1.0 
    });
  const edgeLines = new THREE.LineSegments(edgeGeom, edgeMat);
  
  const group = new THREE.Group();
  group.add(cubeMesh); 
  group.add(edgeLines);
  group.userData = { color: chosenColorHex };
  group.castShadow = true; // Group itself can cast shadow (from cubeMesh)

  if (params.softInternalCubeLight) {
    const internalLight = new THREE.PointLight(chosenColorHex, 0.7, s * 1.5, 2); // color, intensity, distance, decay
    internalLight.castShadow = false; // Internal light should not cast shadows
    cubeMesh.add(internalLight); // Add light as child of the mesh so it's centered
    group.userData.internalLight = internalLight;
  }

  return group;
}

// ========= Build Graph =========
function rebuild() {
  buildGraph();
  rebuildPulses();
}

function buildGraph() {
  graphGroup.clear();
  nodeMeshes = []; edges = [];
  let nodePositions = [];
  const currentRadius = getScaledRadius();
  const currentNodeSize = getScaledNodeSize();
  const currentLineThickness = getScaledLineThickness(); 
  const platonicSolidVertexCounts = [4, 6, 8, 12, 20];
  const isPlatonic = platonicSolidVertexCounts.includes(params.nodeCount);

  if (isPlatonic) {
    nodePositions = getPlatonicSolidVertices(params.nodeCount, currentRadius);
  } else {
    for (let i = 0; i < params.nodeCount; i++) {
      const phi = Math.acos(-1 + (2 * i) / params.nodeCount);
      const theta = Math.sqrt(params.nodeCount * Math.PI) * phi;
      nodePositions.push(new THREE.Vector3( currentRadius * Math.sin(phi) * Math.cos(theta), currentRadius * Math.sin(phi) * Math.sin(theta), currentRadius * Math.cos(phi) ));
    }
  }

  const lineMaterial = new THREE.LineBasicMaterial({ 
      color: new THREE.Color(params.lineColor),
      linewidth: currentLineThickness 
    });
  const nodeGeometry = new THREE.SphereGeometry(currentNodeSize, 16, 16);

  nodePositions.forEach((pos, i) => {
    const nodeMaterial = new THREE.MeshStandardMaterial({ // Changed to MeshStandardMaterial
        color: new THREE.Color(params.nodeColor), 
        emissive: new THREE.Color(params.nodeColor), // Nodes can also be emissive
        emissiveIntensity: 0.3,
        roughness: 0.5,
        metalness: 0.2
    });
    const sphereMesh = new THREE.Mesh(nodeGeometry, nodeMaterial);
    sphereMesh.position.copy(pos);
    sphereMesh.castShadow = true; // Nodes cast shadows
    // sphereMesh.receiveShadow = true; // Nodes can also receive shadows from other nodes/pulses
    graphGroup.add(sphereMesh);
    nodeMeshes.push(sphereMesh);
    for (let j = i + 1; j < nodePositions.length; j++) {
      const lineGeometry = new THREE.BufferGeometry().setFromPoints([pos, nodePositions[j]]);
      // Lines don't cast or receive shadows typically
      graphGroup.add(new THREE.Line(lineGeometry, lineMaterial));
      edges.push({ from: i, to: j });
    }
  });
}

// ========= Pulses =========
function rebuildPulses() {
  pulsesGroup.clear(); pulses = [];
  if (!edges.length || params.pulseCount === 0) return;
  for (let i = 0; i < params.pulseCount; i++) {
    const pulseCube = makeCube(params.cubeInteriorColor); // makeCube now handles internal light
    const edge = edges[Math.floor(Math.random() * edges.length)];
    pulseCube.userData = { from: edge.from, to: edge.to, t: Math.random(), color: pulseCube.userData.color, internalLight: pulseCube.userData.internalLight };
    updatePulsePosition(pulseCube);
    pulsesGroup.add(pulseCube);
    pulses.push(pulseCube);
  }
}

function updatePulsePosition(pulseCube) {
  if (nodeMeshes[pulseCube.userData.from] && nodeMeshes[pulseCube.userData.to]) {
    const startNodePos = nodeMeshes[pulseCube.userData.from].position;
    const endNodePos = nodeMeshes[pulseCube.userData.to].position;
    pulseCube.position.lerpVectors(startNodePos, endNodePos, pulseCube.userData.t);
  }
}

function updatePulse(pulseCube, deltaTime) {
  pulseCube.userData.t += params.pulseSpeed * deltaTime;
  if (pulseCube.userData.t >= 1) {
    const targetNodeIndex = pulseCube.userData.to;
    const pulseActualColor = pulseCube.userData.color;
    if (params.nodeTakesPulseColor && nodeMeshes[targetNodeIndex]) {
        const targetNodeMaterial = nodeMeshes[targetNodeIndex].material;
        targetNodeMaterial.color.setHex(pulseActualColor);
        if (targetNodeMaterial.emissive) {
             targetNodeMaterial.emissive.setHex(pulseActualColor);
        }
    }
    pulseCube.userData.t = 0;
    const connectedEdges = edges.filter(e => e.from === targetNodeIndex || e.to === targetNodeIndex);
    let nextEdge;
    if (connectedEdges.length > 0) {
        nextEdge = connectedEdges[Math.floor(Math.random() * connectedEdges.length)];
        pulseCube.userData.from = targetNodeIndex; 
        pulseCube.userData.to = (nextEdge.from === targetNodeIndex) ? nextEdge.to : nextEdge.from;
    } else if (edges.length > 0) {
        nextEdge = edges[Math.floor(Math.random() * edges.length)];
        pulseCube.userData.from = nextEdge.from; pulseCube.userData.to = nextEdge.to;
    } else { return; }
  }
  updatePulsePosition(pulseCube);
}

// ========= Animation =========
function animate() {
  requestAnimationFrame(animate);
  const deltaTime = clock.getDelta();
  pulses.forEach(p => updatePulse(p, deltaTime));
  
  graphGroup.rotation.x += params.rotationXIncrement; 
  graphGroup.rotation.y += params.rotationYIncrement; 
  graphGroup.rotation.z += params.rotationZIncrement; 
  pulsesGroup.rotation.copy(graphGroup.rotation); 

  renderer.render(scene, camera);
}

// ========= Resize =========
function onResize() {
  if (!renderer || !camera) return;
  const width = window.innerWidth; 
  const height = window.innerHeight;

  camera.aspect = width / height;
  camera.updateProjectionMatrix();
  renderer.setSize(width, height);
}

// ========= Embeddable App Generator =========
function generateEmbeddableApp() {
    const generatedParams = JSON.parse(JSON.stringify(params)); 
    delete generatedParams.generateApp; 

    const generatedCode = `
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Embeddable 3D Node Simulation</title>
  <style>
    body { margin: 0; overflow: hidden; }
    #simulation-canvas-container { 
        width: 100%; 
        height: 500px; /* Default height, user can change */
        position: relative;
    }
    canvas { display: block; }
  </style>
</head>
<body>
  <div id="simulation-canvas-container"></div>

  <script type="module">
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.142.0/build/three.module.js';

    // --- BEGIN USER-CONFIGURABLE PARAMETERS ---
    const config = ${JSON.stringify(generatedParams, null, 2)};
    const EMBED_COLORS = [${COLORS.map(c => "0x" + c.toString(16).padStart(6, '0')).join(', ')}];
    // --- END USER-CONFIGURABLE PARAMETERS ---

    let scene_embed, camera_embed, renderer_embed;
    let graphGroup_embed, pulsesGroup_embed;
    let nodeMeshes_embed = [];
    let edges_embed = [], pulses_embed = [];
    const clock_embed = new THREE.Clock();
    let animationFrameId_embed;
    let directionalLight_embed, hemisphereLight_embed;


    const getScaledRadius_embed = () => config.radius * config.globalScale;
    const getScaledNodeSize_embed = () => config.nodeSize * config.globalScale;
    const getScaledCubeSize_embed = () => config.cubeSize * config.globalScale;
    const getScaledLineThickness_embed = () => config.lineThickness * config.globalScale;

    function init_embed() {
      const container = document.getElementById('simulation-canvas-container');
      if (!container) {
        console.error('Container #simulation-canvas-container not found.');
        return;
      }

      scene_embed = new THREE.Scene();
      camera_embed = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 0.1, 1000);
      camera_embed.position.set(10 * config.globalScale, 10 * config.globalScale, 15 * config.globalScale); 
      camera_embed.lookAt(0, 0, 0);

      renderer_embed = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer_embed.setPixelRatio(window.devicePixelRatio);
      renderer_embed.setSize(container.clientWidth, container.clientHeight);
      renderer_embed.setClearColor(0x000000, 0); 
      renderer_embed.shadowMap.enabled = true;
      renderer_embed.shadowMap.type = THREE.PCFSoftShadowMap;
      container.appendChild(renderer_embed.domElement);

      scene_embed.add(new THREE.AmbientLight(0x404040, 0.5));
      hemisphereLight_embed = new THREE.HemisphereLight(0xffffff, 0x444444, 0.8);
      hemisphereLight_embed.position.set(0, 20 * config.globalScale, 0);
      scene_embed.add(hemisphereLight_embed);

      directionalLight_embed = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight_embed.position.set(15 * config.globalScale, 20 * config.globalScale, 10 * config.globalScale);
      directionalLight_embed.castShadow = true;
      directionalLight_embed.shadow.mapSize.width = 1024; 
      directionalLight_embed.shadow.mapSize.height = 1024;
      directionalLight_embed.shadow.camera.near = 0.5;    
      directionalLight_embed.shadow.camera.far = 50 * config.globalScale;     
      directionalLight_embed.shadow.camera.left = -15 * config.globalScale;
      directionalLight_embed.shadow.camera.right = 15 * config.globalScale;
      directionalLight_embed.shadow.camera.top = 15 * config.globalScale;
      directionalLight_embed.shadow.camera.bottom = -15 * config.globalScale;
      scene_embed.add(directionalLight_embed);

      graphGroup_embed = new THREE.Group();
      pulsesGroup_embed = new THREE.Group();
      scene_embed.add(graphGroup_embed, pulsesGroup_embed);

      window.addEventListener('resize', onResize_embed);
      rebuild_embed();
      if (animationFrameId_embed) cancelAnimationFrame(animationFrameId_embed);
      animate_embed();
    }

    function getPlatonicSolidVertices_embed(count, radius) {
        let points = []; const p = (1 + Math.sqrt(5)) / 2; const ip = 1 / p;
        switch (count) {
            case 4: points = [ new THREE.Vector3(1,1,1),new THREE.Vector3(1,-1,-1),new THREE.Vector3(-1,1,-1),new THREE.Vector3(-1,-1,1) ]; break;
            case 6: points = [ new THREE.Vector3(1,0,0),new THREE.Vector3(-1,0,0),new THREE.Vector3(0,1,0),new THREE.Vector3(0,-1,0),new THREE.Vector3(0,0,1),new THREE.Vector3(0,0,-1) ]; break;
            case 8: points = [ new THREE.Vector3(1,1,1),new THREE.Vector3(1,1,-1),new THREE.Vector3(1,-1,1),new THREE.Vector3(1,-1,-1),new THREE.Vector3(-1,1,1),new THREE.Vector3(-1,1,-1),new THREE.Vector3(-1,-1,1),new THREE.Vector3(-1,-1,-1) ]; break;
            case 12: const X_ico=0.525731112119133606; const Z_ico=0.850650808352039932; points = [ new THREE.Vector3(-X_ico,0,Z_ico),new THREE.Vector3(X_ico,0,Z_ico),new THREE.Vector3(-X_ico,0,-Z_ico),new THREE.Vector3(X_ico,0,-Z_ico),new THREE.Vector3(0,Z_ico,X_ico),new THREE.Vector3(0,Z_ico,-X_ico),new THREE.Vector3(0,-Z_ico,X_ico),new THREE.Vector3(0,-Z_ico,-X_ico),new THREE.Vector3(Z_ico,X_ico,0),new THREE.Vector3(-Z_ico,X_ico,0),new THREE.Vector3(Z_ico,-X_ico,0),new THREE.Vector3(-Z_ico,-X_ico,0) ]; return points.map(pt=>pt.multiplyScalar(radius));
            case 20: points = [ new THREE.Vector3(1,1,1),new THREE.Vector3(1,1,-1),new THREE.Vector3(1,-1,1),new THREE.Vector3(1,-1,-1),new THREE.Vector3(-1,1,1),new THREE.Vector3(-1,1,-1),new THREE.Vector3(-1,-1,1),new THREE.Vector3(-1,-1,-1) ]; const p_coords = [ new THREE.Vector3(0,ip,p),new THREE.Vector3(0,ip,-p),new THREE.Vector3(0,-ip,p),new THREE.Vector3(0,-ip,-p),new THREE.Vector3(ip,p,0),new THREE.Vector3(ip,-p,0),new THREE.Vector3(-ip,p,0),new THREE.Vector3(-ip,-p,0),new THREE.Vector3(p,0,ip),new THREE.Vector3(p,0,-ip),new THREE.Vector3(-p,0,ip),new THREE.Vector3(-p,0,-ip) ]; p_coords.forEach(v=>points.push(v)); break;
            default: return [];
        }
        return points.map(pt => pt.normalize().multiplyScalar(radius));
    }

    function makeCube_embed(defaultColor) {
      const s = getScaledCubeSize_embed();
      const geom = new THREE.BoxGeometry(s,s,s);
      let chosenColorHex;
      if (config.randomCubeColor) { chosenColorHex = EMBED_COLORS[Math.floor(Math.random() * EMBED_COLORS.length)]; }
      else { chosenColorHex = new THREE.Color(defaultColor).getHex(); }
      
      const isTransparent_embed = config.softInternalCubeLight;
      const opacity_embed = isTransparent_embed ? 0.85 : 1.0;

      const fillMaterial = new THREE.MeshStandardMaterial({
          color:chosenColorHex, 
          emissive:chosenColorHex, 
          emissiveIntensity: config.softInternalCubeLight ? 0.5 : 0.2,
          roughness: 0.6, 
          metalness: 0.1,
          transparent: isTransparent_embed,
          opacity: opacity_embed
        });
      const cubeMesh = new THREE.Mesh(geom, fillMaterial);
      cubeMesh.castShadow = true;

      const edgeGeom = new THREE.EdgesGeometry(geom);
      const edgeMat = new THREE.LineBasicMaterial({
          color:0x000000, 
          transparent: isTransparent_embed, 
          opacity: isTransparent_embed ? 0.5 : 1.0
        });
      const edgeLines = new THREE.LineSegments(edgeGeom, edgeMat);
      const group = new THREE.Group(); group.add(cubeMesh); group.add(edgeLines);
      group.userData = {color: chosenColorHex};
      group.castShadow = true;

      if (config.softInternalCubeLight) {
        const internalLight_embed = new THREE.PointLight(chosenColorHex, 0.7, s * 1.5, 2);
        internalLight_embed.castShadow = false;
        cubeMesh.add(internalLight_embed); // Add to mesh to be centered
        group.userData.internalLight = internalLight_embed;
      }
      return group;
    }

    function rebuild_embed() { 
        // Update light positions based on scale before rebuilding graph
        if (directionalLight_embed) {
            directionalLight_embed.position.set(15 * config.globalScale, 20 * config.globalScale, 10 * config.globalScale);
            directionalLight_embed.shadow.camera.left = -15 * config.globalScale;
            directionalLight_embed.shadow.camera.right = 15 * config.globalScale;
            directionalLight_embed.shadow.camera.top = 15 * config.globalScale;
            directionalLight_embed.shadow.camera.bottom = -15 * config.globalScale;
            directionalLight_embed.shadow.camera.far = 50 * config.globalScale;   
            directionalLight_embed.shadow.camera.updateProjectionMatrix();
        }
        if (hemisphereLight_embed) {
            hemisphereLight_embed.position.set(0, 20 * config.globalScale, 0);
        }
        if (camera_embed) { // Also adjust camera if it's tied to scale, though currently fixed
             camera_embed.position.set(10 * config.globalScale, 10 * config.globalScale, 15 * config.globalScale);
             camera_embed.lookAt(0,0,0);
        }


        buildGraph_embed(); 
        rebuildPulses_embed(); 
    }

    function buildGraph_embed() {
      graphGroup_embed.clear(); nodeMeshes_embed = []; edges_embed = [];
      let nodePositions = [];
      const currentRadius = getScaledRadius_embed();
      const currentNodeSize = getScaledNodeSize_embed();
      const currentLineThickness = getScaledLineThickness_embed(); 
      const platonicSolidVertexCounts = [4,6,8,12,20];
      const isPlatonic = platonicSolidVertexCounts.includes(config.nodeCount);
      if (isPlatonic) { nodePositions = getPlatonicSolidVertices_embed(config.nodeCount, currentRadius); }
      else {
        for (let i=0; i<config.nodeCount; i++) {
          const phi = Math.acos(-1 + (2*i)/config.nodeCount);
          const theta = Math.sqrt(config.nodeCount * Math.PI) * phi;
          nodePositions.push(new THREE.Vector3(currentRadius*Math.sin(phi)*Math.cos(theta), currentRadius*Math.sin(phi)*Math.sin(theta), currentRadius*Math.cos(phi)));
        }
      }
      const lineMaterial = new THREE.LineBasicMaterial({
          color: new THREE.Color(config.lineColor),
          linewidth: currentLineThickness 
        });
      const nodeGeometry = new THREE.SphereGeometry(currentNodeSize,16,16);
      nodePositions.forEach((pos,i) => {
        const nodeMaterial = new THREE.MeshStandardMaterial({
            color: new THREE.Color(config.nodeColor), 
            emissive: new THREE.Color(config.nodeColor),
            emissiveIntensity: 0.3,
            roughness: 0.5, metalness: 0.2
        });
        const sphereMesh = new THREE.Mesh(nodeGeometry, nodeMaterial);
        sphereMesh.position.copy(pos); 
        sphereMesh.castShadow = true;
        // sphereMesh.receiveShadow = true; // Optional
        graphGroup_embed.add(sphereMesh); nodeMeshes_embed.push(sphereMesh);
        for (let j=i+1; j<nodePositions.length; j++) {
          const lineGeom = new THREE.BufferGeometry().setFromPoints([pos, nodePositions[j]]);
          graphGroup_embed.add(new THREE.Line(lineGeom, lineMaterial)); edges_embed.push({from:i,to:j});
        }
      });
    }

    function rebuildPulses_embed() {
      pulsesGroup_embed.clear(); pulses_embed = [];
      if (!edges_embed.length || config.pulseCount === 0) return;
      for (let i=0; i<config.pulseCount; i++) {
        const pulseCube = makeCube_embed(config.cubeInteriorColor);
        const edge = edges_embed[Math.floor(Math.random()*edges_embed.length)];
        pulseCube.userData = {from:edge.from, to:edge.to, t:Math.random(), color:pulseCube.userData.color, internalLight: pulseCube.userData.internalLight};
        updatePulsePosition_embed(pulseCube); pulsesGroup_embed.add(pulseCube); pulses_embed.push(pulseCube);
      }
    }

    function updatePulsePosition_embed(pulseCube) {
      if (nodeMeshes_embed[pulseCube.userData.from] && nodeMeshes_embed[pulseCube.userData.to]) {
        const start = nodeMeshes_embed[pulseCube.userData.from].position;
        const end = nodeMeshes_embed[pulseCube.userData.to].position;
        pulseCube.position.lerpVectors(start,end,pulseCube.userData.t);
      }
    }

    function updatePulse_embed(pulseCube, deltaTime) {
      pulseCube.userData.t += config.pulseSpeed * deltaTime;
      if (pulseCube.userData.t >= 1) {
        const targetIdx = pulseCube.userData.to;
        const color = pulseCube.userData.color;
        if (config.nodeTakesPulseColor && nodeMeshes_embed[targetIdx]) {
          const targetNodeMaterial_embed = nodeMeshes_embed[targetIdx].material;
          targetNodeMaterial_embed.color.setHex(color);
          if(targetNodeMaterial_embed.emissive) targetNodeMaterial_embed.emissive.setHex(color);
        }
        pulseCube.userData.t = 0;
        const connected = edges_embed.filter(e => e.from === targetIdx || e.to === targetIdx);
        let nextEdge;
        if (connected.length > 0) { nextEdge = connected[Math.floor(Math.random()*connected.length)]; pulseCube.userData.from = targetIdx; pulseCube.userData.to = (nextEdge.from === targetIdx) ? nextEdge.to : nextEdge.from; }
        else if (edges_embed.length > 0) { nextEdge = edges_embed[Math.floor(Math.random()*edges_embed.length)]; pulseCube.userData.from = nextEdge.from; pulseCube.userData.to = nextEdge.to; }
        else { return; }
      }
      updatePulsePosition_embed(pulseCube);
    }

    function animate_embed() {
      animationFrameId_embed = requestAnimationFrame(animate_embed);
      const dt = clock_embed.getDelta();
      pulses_embed.forEach(p => updatePulse_embed(p, dt));
      
      graphGroup_embed.rotation.x += config.rotationXIncrement; 
      graphGroup_embed.rotation.y += config.rotationYIncrement; 
      graphGroup_embed.rotation.z += config.rotationZIncrement; 
      pulsesGroup_embed.rotation.copy(graphGroup_embed.rotation);

      renderer_embed.render(scene_embed, camera_embed);
    }

    function onResize_embed() {
      const container = document.getElementById('simulation-canvas-container');
      if (!renderer_embed || !camera_embed || !container) return;
      const width = container.clientWidth;
      const height = container.clientHeight;
      camera_embed.aspect = width / height;
      camera_embed.updateProjectionMatrix();
      renderer_embed.setSize(width, height);
    }

    // --- BEGIN SIMULATION API ---
    window.simulationAPI = {
      updateConfig: function(newConfigUpdates) {
        let needsRebuild = false;
        let needsRebuildPulses = false;
        let needsNodeColorUpdate = false;
        let needsLineColorUpdate = false; 

        for (const key in newConfigUpdates) {
            if (config.hasOwnProperty(key)) {
                config[key] = newConfigUpdates[key]; 

                if (['globalScale', 'nodeCount', 'radius', 'nodeSize', 'cubeSize', 'lineThickness'].includes(key)) {
                    needsRebuild = true;
                } else if (key === 'nodeColor') {
                    needsNodeColorUpdate = true;
                } else if (key === 'lineColor') { 
                    needsLineColorUpdate = true;
                } else if (['pulseCount', 'cubeInteriorColor', 'randomCubeColor', 'softInternalCubeLight'].includes(key)) {
                    if (key === 'cubeInteriorColor' && config.randomCubeColor) { /* no action */ }
                    else { needsRebuildPulses = true; }
                }
            } else {
                console.warn(\`simulationAPI.updateConfig: Unknown config key "\${key}"\`);
            }
        }

        if (needsRebuild) {
            rebuild_embed(); 
        } else { 
            if (needsRebuildPulses) {
                rebuildPulses_embed();
            }
            if (needsNodeColorUpdate && nodeMeshes_embed) {
                const colorObj = new THREE.Color(config.nodeColor);
                nodeMeshes_embed.forEach(mesh => { 
                    if(mesh.material) { // Check if material exists
                        mesh.material.color.set(colorObj);
                        if(mesh.material.emissive) mesh.material.emissive.set(colorObj);
                    }
                });
            }
            if (needsLineColorUpdate && graphGroup_embed) { 
                const colorObj = new THREE.Color(config.lineColor);
                graphGroup_embed.children.forEach(child => {
                    if (child instanceof THREE.Line && child.material instanceof THREE.LineBasicMaterial) {
                        child.material.color.set(colorObj);
                    }
                });
            }
        }
      },
      setGlobalScale: function(value) { this.updateConfig({ globalScale: value }); },
      setNodeCount: function(value) { this.updateConfig({ nodeCount: value }); },
      setNodeColor: function(hexString) { this.updateConfig({ nodeColor: hexString }); },
      setLineColor: function(hexString) { this.updateConfig({ lineColor: hexString }); },
      setLineThickness: function(value) { this.updateConfig({ lineThickness: value }); },
      setRadius: function(value) { this.updateConfig({ radius: value }); },
      setNodeSize: function(value) { this.updateConfig({ nodeSize: value }); },
      setCubeSize: function(value) { this.updateConfig({ cubeSize: value }); },
      setPulseCount: function(value) { this.updateConfig({ pulseCount: value }); },
      setPulseSpeed: function(value) { this.updateConfig({ pulseSpeed: value }); },
      setRotationXIncrement: function(value) { this.updateConfig({ rotationXIncrement: value }); },
      setRotationYIncrement: function(value) { this.updateConfig({ rotationYIncrement: value }); },
      setRotationZIncrement: function(value) { this.updateConfig({ rotationZIncrement: value }); },
      setCubeInteriorColor: function(hexString) { this.updateConfig({ cubeInteriorColor: hexString }); },
      setRandomCubeColor: function(booleanValue) { this.updateConfig({ randomCubeColor: booleanValue }); },
      setSoftInternalCubeLight: function(booleanValue) { this.updateConfig({ softInternalCubeLight: booleanValue }); },
      setNodeTakesPulseColor: function(booleanValue) { this.updateConfig({ nodeTakesPulseColor: booleanValue }); },
      
      getCurrentConfig: function() { return JSON.parse(JSON.stringify(config)); }
    };
    // --- END SIMULATION API ---


    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', init_embed);
    } else {
        init_embed();
    }
    
    window.cleanupSimulation = () => {
        if (animationFrameId_embed) cancelAnimationFrame(animationFrameId_embed);
        window.removeEventListener('resize', onResize_embed);
        if (renderer_embed && renderer_embed.domElement && renderer_embed.domElement.parentElement) {
            renderer_embed.domElement.parentElement.removeChild(renderer_embed.domElement);
        }
        if (renderer_embed) renderer_embed.dispose();
        scene_embed = null; camera_embed = null; renderer_embed = null; 
        graphGroup_embed = null; pulsesGroup_embed = null;
        nodeMeshes_embed = []; edges_embed = []; pulses_embed = [];
    };

  <\/script> 
</body>
</html>
`; 

    const codeOutputTextarea = document.getElementById('generatedCodeOutput');
    const codeContainerDiv = document.getElementById('generatedCodeContainer');
    
    codeOutputTextarea.value = generatedCode;
    codeContainerDiv.style.display = 'block';

    console.log("Generated embeddable app code is ready in the text area on the page.");
    alert("Generated embeddable app code is now available in the text area on the page. You can copy it from there.");
}


</script>
</body>
</html>

